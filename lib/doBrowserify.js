"use strict";

var _ = require("underscore");
var path = require("path");
var browserify = require("browserify");
var urlize = require("./utils").urlize;

// This module does something a bit unorthodox: it uses Browserify to output a single file for each module, instead of
// squashing them all into one in the usual way. The result is, in order:
//
// * A prelude file `browserify.js`, containing all of Browserify's `require` definitions, plus its two "core" built-in
//   modules (viz. `path` and `process`), plus anything (e.g. preludes) added by middleware.
// * A set of wrapped modules that will be aliased, e.g. if you alias `jquery-browserify` to `jquery`, it creates files
//   for `jquery-browserify`.
// * An aliases file `browserify-aliases.js`, containing calls to `require.alias` for each aliased file.
// * Wrapped module files for the entry file and all its dependencies, recursively. This includes Browserify built-ins
//   apart from `path` and `process`.
//
// All this requires twisting Browserify in strange and unusual ways, so things can get a bit hard to follow. We try to
// comment.

function isCoreBuiltin(filePath) {
    // The "core" built-in modules must be bundled into the prelude file, since the definitions of Browserify's
    // `require` depend on them: they cannot be split out into separate files.
    var pieces = filePath.split(path.sep).slice(-3);

    return _.isEqual(pieces, ["browserify", "builtins", "path.js"]) ||
           _.isEqual(pieces, ["browserify", "builtins", "__browserify_process.js"]);
}

function createWrappedFilesMap(bundle) {
    // The `bundle.files` property maps absolute file paths to unwrapped module bodies. Use it to create a map
    // of absolute file paths to wrapped module bodies.
    var files = Object.create(null);
    Object.keys(bundle.files).forEach(function (filePath) {
        if (!isCoreBuiltin(filePath)) {
            var file = bundle.files[filePath];
            var moduleId = file.target || urlize(path.relative(process.cwd(), filePath));
            files[filePath] = bundle.wrap(moduleId, file.body);
        }
    });
    return files;
}

function makePreludeFile(middleware) {
    // Create a bundle. It currently contains the prelude and the core built-ins.
    var bundle = browserify({ cache: true });

    // Install the middleware, in case it adds a prelude or the like.
    middleware.forEach(bundle.use.bind(bundle));

    // This will return a string containing the contents of the prelude file, i.e. all the Browserify definitions
    // (`require`, `require.define`, etc.), plus `require.define` calls for defining the core built-ins.
    return bundle.bundle();
}

function makeAliasesFile(aliases) {
    // Create a bundle with the aliases. It currently contains the prelude, the aliases, and the core built-ins.
    var bundle = browserify({ require: aliases, cache: true });

    // Remove all actual files and the prelude: we just want the `require.alias` calls.
    bundle.files = {};
    bundle.prepends = [];

    // This will return a string containing the the `require.alias` calls generated by passing in the aliases above.
    return bundle.bundle();
}

function makeWrappedAliasedModules(aliases) {
    // Create a bundle with the aliases in it, but remove the builtins.
    var bundle = browserify({ require: aliases, cache: true });

    // Turn it into a relative file path → wrapped module bodies map.
    return createWrappedFilesMap(bundle);
}

function makeWrappedModules(aliases, middleware, entryFile) {
    var bundle = browserify({ cache: true });

    // We manually call `bundle.alias` here so that the files we include know about the aliases during build time, even
    // though the actual aliased file contents will be output separately, and the `require.alias` calls will end up in
    // their own aliases file.
    Object.keys(aliases).forEach(function (alias) {
        bundle.alias(alias, aliases[alias]);
    });

    // Install any middleware in this bundle, so that if it registers extensions, they work.
    middleware.forEach(bundle.use.bind(bundle));

    // Just require the entry file: this will create entries in the `bundle.files` map for all files it requires,
    // recursively.
    bundle.require(path.resolve(entryFile));

    // Turn it into a relative file path → wrapped module bodies map.
    return createWrappedFilesMap(bundle);
}

module.exports = function (grunt, config) {
    var middleware = config.middleware || [];

    // This is the array of URLs for the files we write out, to be returned to the caller.
    var newFileUrls = [];

    function asInDest(filePath) {
        // Takes an absolute path and makes it a relative path, but inside config.dest.
        var relativePath = path.relative(process.cwd(), filePath);
        return path.relative(process.cwd(), path.resolve(config.dest, relativePath));
    }

    function writeFile(description, filePath, contents) {
        var destFilePath = asInDest(filePath);
        var destFileUrl = urlize(destFilePath);

        grunt.file.write(destFilePath, contents);
        grunt.log.writeln("Browserify " + description + " created at \"" + destFilePath + "\"");

        newFileUrls.push(destFileUrl);
    }

    // Write the prelude file, containing middleware preludes, all the Browserify `require` definitions, and the core
    // builtins.
    writeFile("prelude", "browserify.js", makePreludeFile(middleware));

    // Write the files for aliased modules.
    var aliasedModules = makeWrappedAliasedModules(config.aliases);
    Object.keys(aliasedModules).forEach(function (filePath) {
        writeFile("module", filePath, aliasedModules[filePath]);
    });

    // Write the aliases file, containing the `require.alias` declarations.
    writeFile("aliases file", "browserify-aliases.js", makeAliasesFile(config.aliases));

    // Finally, wrap the entry module and all its dependencies, recursively; write those.
    var wrappedModules = makeWrappedModules(config.aliases, middleware, config.entry);
    Object.keys(wrappedModules).forEach(function (filePath) {
        writeFile("module", filePath, wrappedModules[filePath]);
    });

    return newFileUrls;
};
